#pragma once

#include <stdexcept>

#include <etsi_its_{{ etsi_type }}_coding/asn_SEQUENCE_OF.h>
#include <etsi_its_{{ etsi_type }}_coding/{{ t_name }}.h>
{% for member in members -%}
#include <etsi_its_{{ etsi_type }}_coding/{{ member.type|replace("[]", "") }}.h>
#include <etsi_its_{{ etsi_type }}_conversion/convert{{ member.type|replace("[]", "") }}.h>
#include <etsi_its_{{ etsi_type }}_msgs/{{ member.type|replace("[]", "") }}.h>
{% endfor -%}
#include <etsi_its_{{ etsi_type }}_msgs/{{ t_name }}.h>


namespace etsi_its_{{ etsi_type }}_conversion {

void toRos_{{ t_name }}(const {{ t_name }}_t& in, etsi_its_{{ etsi_type }}_msgs::{{ t_name }}& out) {
{% for member in members %}
  for (int i = 0; i < in.list.count; i++) {
    etsi_its_{{ etsi_type }}_msgs::{{ member.type|replace("[]", "") }} {{ member.name }};
    toRos_{{ member.type|replace("[]", "") }}(*(in.list.array[i]), {{ member.name }});
    out.array.push_back({{ member.name }});
  }
{% endfor %}
}

void toStruct_{{ t_name }}(const etsi_its_{{ etsi_type }}_msgs::{{ t_name }}& in, {{ t_name }}_t& out) {
    
  memset(&out, 0, sizeof({{ t_name }}_t));
{% for member in members %}
  for (int i = 0; i < in.array.size(); i++) {
    {{ member.type|replace("[]", "") }}_t {{ member.name }};
    toStruct_{{ member.type|replace("[]", "") }}(in.array[i], {{ member.name }});
    {{ member.type|replace("[]", "") }}_t* {{ member.name }}_ptr = new {{ member.type|replace("[]", "") }}_t({{ member.name }});
    int status = asn_sequence_add(&out, {{ member.name }}_ptr);
    if (status != 0) throw std::invalid_argument("Failed to add to A_SEQUENCE_OF");
  }
{% endfor %}
}

}
